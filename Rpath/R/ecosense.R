################################################################################
#
# *Ecosense function for the fishing branch of Rpath*
#
# To merge branches we need to rewrite the ecosense parameter generation
# function. This new function is loosely based on the rsim.params function,
# where the Ecopath outputs are converted into rates for use with Ecosim.
#
# Similar to Rsim.scenario, the object returned by this Ecosense function will
# have the same attributes as the rsim object and can be supplied to the
# rsim.run function.
#
################################################################################
#'Ecosense modual of Rpath
#'
#'@family Rpath functions
#'
#'@param Rpath.scenario R object that is generated by the rsim.scenario
#' function and can be supplied to the rsim.run function.
#'@param Rpath R object containing a balanced Rpath model.
#'@param Rpath.params R object containing the Rpath parameters.  This is generated
#'  either by the create.rpath.params or read.rpath.params functions.
#'
#'
#'@return Returns an Rsim.scenario object that can be supplied to the rsim.run function.
#'@export

# rsim.scenario has already produced the 5 core list objects that need to be
# supplied to rsim.run(): params, start_state, forcing, fishing, stanzas.
# In rsim.sense() we are only concerned with changing those 'params' which have
# uncertainty incorporated in them as part of the ecosense routine, or are
# otherwise derivative from the uncertain parameters (e.g., parameters that are
# intermediate steps in the calculation of sim parameters, larger for-loops
# which may include one (or more) parameter(s) that incorporates uncertainty
# from one of the base parameters).

rsim.sense <- function(Rpath.scenario, Rpath, Rpath.params, mscramble = 2,
                       mhandle = 1000, preyswitch = 1, scrambleselfwt = 1,
                       handleselfwt = 1, steps_yr = 12, steps_m = 1)   {

  sense.params <- Rpath.scenario$params
  
  MHANDLE        <- 1000.0

  nliving <- Rpath$NUM_LIVING
  ndead   <- Rpath$NUM_DEAD
  
  # Set-up pedigree vectors, including zeroes for gear groups.
  BBVAR	<- c(as.numeric(unlist(Rpath.params$pedigree[,2])),rep(0,Rpath$NUM_GEARS))
  PBVAR	<- c(as.numeric(unlist(Rpath.params$pedigree[,3])),rep(0,Rpath$NUM_GEARS))
  QBVAR	<- c(as.numeric(unlist(Rpath.params$pedigree[,4])),rep(0,Rpath$NUM_GEARS))
  DCVAR	<- c(as.numeric(unlist(Rpath.params$pedigree[,5])),rep(0,Rpath$NUM_GEARS))
  
  
  # Biomass
  ranBB <- Rpath$BB * (1 + BBVAR * runif(Rpath$NUM_GROUPS,-1.0,1.0))
  sense.params$B_BaseRef <- c(1.0, ranBB)
  # PB
  ranPB <- Rpath$PB * (1 + PBVAR * runif(Rpath$NUM_GROUPS,-1.0,1.0))
  # QB
  ranQB <- Rpath$QB * (1 + QBVAR * runif(Rpath$NUM_GROUPS,-1.0,1.0))
  
  # Mzero
  sense.params$MzeroMort <- c(0.0, ranPB * (1.0 - Rpath$EE)  *
                                (1 + PBVAR * runif(Rpath$NUM_GROUPS,-1.0,1.0)))
  # The zero at the start of the M0 vector is for "outside"
  # same for the other vectors
  
  #Active respiration is proportion of CONSUMPTION that goes to "heat"
  #Passive respiration/ VonB adjustment is left out here
  sense.params$ActiveRespFrac <-  c(0.0, ifelse(ranQB > 0, 
                                                1.0 - (ranPB / ranQB) - Rpath$GS, 
                                                0.0))
  
  #####	rQBPrimProd is a added here because we need a non-zero QB for
  #####	primary production groups. QB's of zero produce NaN's in ecosim
  #####	and just bring the whole thing to a screaching hault. rQBPrimProd
  #####	sets the QB of PP groups equal to their PB.
  rQBPrimProd	<- ifelse(Rpath$type==1,ranPB,ranQB)
  sense.params$FtimeQBOpt <-   c(1.0, rQBPrimProd)
  #sense.params$FtimeQBOpt <-   c(1.0, ranQB)
  sense.params$PBopt      <-   c(1.0, ranPB)           
  
  #No Integrate
  sense.params$NoIntegrate <- ifelse(sense.params$MzeroMort * sense.params$B_BaseRef > 
                                       2 * steps_yr * steps_m, 0, sense.params$spnum)
  
  #primary production links
  primTo   <- ifelse(Rpath$type > 0 & Rpath$type <= 1, 
                     1:length(ranPB),
                     0)
  primFrom <- rep(0, length(Rpath$PB))
  primQ    <- ranPB * ranBB 
  
  # Change production to consusmption for mixotrophs
  mixotrophs <- which(Rpath$type > 0 & Rpath$type < 1)
  primQ[mixotrophs] <- primQ[mixotrophs] / Rpath$GE[mixotrophs] * 
    Rpath$type[mixotrophs]
  
  #Predator/prey links
  preyfrom  <- row(Rpath$DC)
  preyto    <- col(Rpath$DC)	
  predpreyQ <- Rpath$DC[1:(nliving + ndead + 1), ] * 
    t(matrix(rQBPrimProd[1:Rpath$NUM_LIVING] * ranBB[1:Rpath$NUM_LIVING],
             nliving, nliving + ndead + 1))
  
  #combined
  sense.params$PreyFrom <- c(primFrom[primTo > 0], preyfrom [predpreyQ > 0])
  # Changed import prey number to 0
  sense.params$PreyFrom[which(sense.params$PreyFrom == nrow(Rpath$DC))] <- 0
  sense.params$PreyTo   <- c(primTo  [primTo > 0], preyto   [predpreyQ > 0])
  
  ##### This is where we add uncertainty to diet  #####
  # Diet comp vector
  DCvector <- c(rep(0.0, sum(Rpath$type==1)), Rpath$DC[Rpath$DC>0])
  # Diet comp pedigree
  DCped <- as.numeric(unlist(Rpath.params$pedigree[,5]))
  DCpedigree <- DCped[sense.params$PreyTo]
  ## Random diet comp
  EPSILON <- 1*10^-8
  betascale <- 1.0
  DCbeta <- betascale * DCpedigree * DCpedigree
  alpha <- DCvector/DCbeta
  DClinks <- rgamma(length(DCvector), shape=alpha, rate=DCbeta)
  DClinks2 <- ifelse(DClinks < EPSILON, 2 * EPSILON, DClinks)
  # DClinks2 prevents random diet comps from becoming too low, effectively
  # equal to zero. Zeros in DClinks will produce NaN's in sense.params$QQ, and
  # others, ultimately preventing ecosim.
  DCtot <- tapply(DClinks2, sense.params$PreyTo, "sum")    
  # Normalized diet comp
  DCnorm <- ifelse(Rpath$type[sense.params$PreyTo]==1, 1.0, DClinks2/DCtot[sense.params$PreyTo])
  # The "if" part of DCnorm is so the DC of phytoplankton (type==1) won't equal zero
  DCQB <- rQBPrimProd[sense.params$PreyTo]
  DCBB <- ranBB[sense.params$PreyTo]  
  sense.params$QQ <- DCnorm * DCQB * DCBB             	
  
  numpredprey <- length(sense.params$QQ)
  
  # Sarah used the following formula to vary vulnerability in Gaichas et al. (2012)
  # That paper states that "vulnerability" (also known as X*predprey) has an
  # effective range from 1.01 to 91 in EwE.
  
  # KYA Added re-initialization of DD so we're not using the old version that has the 0 added!
  sense.params$VV	<-	1 + exp(9 * (runif(numpredprey)-0.5))
  sense.params$DD <-  rep(MHANDLE, numpredprey)
  
  # Scramble combined prey pools
  Btmp <- sense.params$B_BaseRef
  py   <- sense.params$PreyFrom + 1.0
  pd   <- sense.params$PreyTo + 1.0
  VV   <- sense.params$VV * sense.params$QQ / Btmp[py]
  AA   <- (2.0 * sense.params$QQ * VV) / (VV * Btmp[pd] * Btmp[py] - sense.params$QQ * Btmp[pd])
  sense.params$PredPredWeight <- AA * Btmp[pd] 
  sense.params$PreyPreyWeight <- AA * Btmp[py] 
  
  sense.params$PredTotWeight <- rep(0, length(sense.params$B_BaseRef))
  sense.params$PreyTotWeight <- rep(0, length(sense.params$B_BaseRef))
  
  for(links in 1:numpredprey){
    sense.params$PredTotWeight[py[links]] <- sense.params$PredTotWeight[py[links]] + sense.params$PredPredWeight[links]
    sense.params$PreyTotWeight[pd[links]] <- sense.params$PreyTotWeight[pd[links]] + sense.params$PreyPreyWeight[links]    
  }  
  
  sense.params$PredPredWeight <- sense.params$PredPredWeight/sense.params$PredTotWeight[py]
  sense.params$PreyPreyWeight <- sense.params$PreyPreyWeight/sense.params$PreyTotWeight[pd]
  
  sense.params$PreyFrom       <- c(0, sense.params$PreyFrom)
  sense.params$PreyTo         <- c(0, sense.params$PreyTo)
  sense.params$QQ             <- c(0, sense.params$QQ)
  sense.params$DD             <- c(0, sense.params$DD)
  sense.params$VV             <- c(0, sense.params$VV) 
  sense.params$PredPredWeight <- c(0, sense.params$PredPredWeight)
  sense.params$PreyPreyWeight <- c(0, sense.params$PreyPreyWeight)
  
  
  #catchlinks
  fishfrom    <- row(as.matrix(Rpath$Catch))
  fishthrough <- col(as.matrix(Rpath$Catch)) + (nliving + ndead)
  fishcatch   <- Rpath$Catch
  fishto      <- fishfrom * 0
  
  if(sum(fishcatch) > 0){
    sense.params$FishFrom    <- fishfrom   [fishcatch > 0]
    sense.params$FishThrough <- fishthrough[fishcatch > 0]
    sense.params$FishQ       <- fishcatch  [fishcatch > 0] / sense.params$B_BaseRef[sense.params$FishFrom + 1]  
    sense.params$FishTo      <- fishto     [fishcatch > 0]
  }
  
  #discard links
  for(d in 1:Rpath$NUM_DEAD){
    detfate <- Rpath$DetFate[(nliving + ndead + 1):Rpath$NUM_GROUPS, d]
    detmat  <- t(matrix(detfate, Rpath$NUM_GEAR, Rpath$NUM_GROUPS))
    
    fishfrom    <-  row(as.matrix(Rpath$Discards))                      
    fishthrough <-  col(as.matrix(Rpath$Discards)) + (nliving + ndead)
    fishto      <-  t(matrix(nliving + d, Rpath$NUM_GEAR, Rpath$NUM_GROUPS))
    fishcatch   <-  Rpath$Discards * detmat
    if(sum(fishcatch) > 0){
      sense.params$FishFrom    <- c(sense.params$FishFrom,    fishfrom   [fishcatch > 0])
      sense.params$FishThrough <- c(sense.params$FishThrough, fishthrough[fishcatch > 0])
      ffrom <- fishfrom[fishcatch > 0]
      sense.params$FishQ       <- c(sense.params$FishQ,  fishcatch[fishcatch > 0] / sense.params$B_BaseRef[ffrom + 1])  
      sense.params$FishTo      <- c(sense.params$FishTo, fishto   [fishcatch > 0])
    }
  } 
  
  sense.params$FishFrom        <- c(0, sense.params$FishFrom)
  sense.params$FishThrough     <- c(0, sense.params$FishThrough)
  sense.params$FishQ           <- c(0, sense.params$FishQ)  
  sense.params$FishTo          <- c(0, sense.params$FishTo)   
  
  
  class(sense.params) <- 'Rsim.params'
  return(sense.params)   
  
}

################################################################################ 
#'@export
ecosim.random.params <- function(Rpath){
  #
  # TODO Add Randomness to simpar below based on matrix Rpath$pedigree
  # ## MZERO USED AS AN EXAMPLE BELOW
  
  #Old path_to_rates--------------------------------------------------------------------
  MSCRAMBLE      <- 2.0
  MHANDLE        <- 1000.0
  PREYSWITCH     <- 1.0
  # For SelfWts 1.0 = no overlap, 0.0 = complete overlap
  ScrambleSelfWt <- 1.0
  HandleSelfWt   <- 1.0
  
  simpar <- c()
  
  simpar$NUM_GROUPS <- Rpath$NUM_GROUPS
  simpar$NUM_LIVING <- Rpath$NUM_LIVING
  simpar$NUM_DEAD   <- Rpath$NUM_DEAD
  simpar$NUM_GEARS  <- Rpath$NUM_GEARS
  
  simpar$spname     <- c("Outside", Rpath$Group)
  simpar$spnum      <- 0:length(Rpath$BB) 
  
  #Energetics for Living and Dead Groups
  #Reference biomass for calculating YY
  simpar$B_BaseRef <- c(1.0, Rpath$BB) 
  #Mzero proportional to (1-EE)
  # SCALE TO Mzero +/- Mzero * PBpedigree *uniform(-1,1) 
  simpar$MzeroMort <- c(0.0, Rpath$PB * (1.0 - Rpath$EE))  *
        (1 + EBS$pedigree[,2] * runif(EBS$NUM_LIVING+EBS$NUM_DEAD,-1.0,1.0) )
            
  #Unassimilated is the proportion of CONSUMPTION that goes to detritus.  
  simpar$UnassimRespFrac <- c(0.0, Rpath$GS);
  #Active respiration is proportion of CONSUMPTION that goes to "heat"
  #Passive respiration/ VonB adjustment is left out here
  simpar$ActiveRespFrac <-  c(0.0, ifelse(Rpath$QB > 0, 
                                          1.0 - (Rpath$PB / Rpath$QB) - Rpath$GS, 
                                          0.0))
  #Ftime related parameters
  simpar$FtimeAdj   <- rep(0.0, length(simpar$B_BaseRef))
  simpar$FtimeQBOpt <-   c(1.0, Rpath$QB)
  simpar$PBopt      <-   c(1.0, Rpath$PB)           
  
  #Fishing Effort defaults to 0 for non-gear, 1 for gear
  #KYA EFFORT REMOVED FROM PARAMS July 2015
  simpar$fish_Effort <- ifelse(simpar$spnum <= simpar$NUM_LIVING + simpar$NUM_DEAD,
                               0.0,
                               1.0) 
  
  #NoIntegrate
  STEPS_PER_YEAR  <- 12
  STEPS_PER_MONTH <- 1
  simpar$NoIntegrate <- ifelse(c(0, Rpath$PB) / 
                                 (1.0 - simpar$ActiveRespFrac - simpar$UnassimRespFrac) > 
                                 2 * STEPS_PER_YEAR * STEPS_PER_MONTH, 
                               0, 
                               simpar$spnum)  
  
  #Pred/Prey defaults
  simpar$HandleSelf   <- rep(HandleSelfWt,   Rpath$NUM_GROUPS + 1)
  simpar$ScrambleSelf <- rep(ScrambleSelfWt, Rpath$NUM_GROUPS + 1)
  
  #primary production links
  #primTo   <- ifelse(Rpath$PB>0 & Rpath$QB<=0, 1:length(Rpath$PB),0 )
  primTo   <- ifelse(Rpath$type == 1, 
                     1:length(Rpath$PB),
                     0)
  primFrom <- rep(0, length(Rpath$PB))
  primQ    <- Rpath$PB * Rpath$BB 
  
  #Predator/prey links
  preyfrom  <- row(Rpath$DC)
  preyto    <- col(Rpath$DC)	
  predpreyQ <- Rpath$DC * t(matrix(Rpath$QB[1:Rpath$NUM_LIVING] * Rpath$BB[1:Rpath$NUM_LIVING],
                                   Rpath$NUM_LIVING, Rpath$NUM_LIVING + Rpath$NUM_DEAD))
  
  #combined
  simpar$PreyFrom <- c(primFrom[primTo > 0], preyfrom [predpreyQ > 0])
  simpar$PreyTo   <- c(primTo  [primTo > 0], preyto   [predpreyQ > 0])
  simpar$QQ       <- c(primQ   [primTo > 0], predpreyQ[predpreyQ > 0])             	
  
  numpredprey <- length(simpar$QQ)
  
  simpar$DD <- rep(MHANDLE,   numpredprey)
  simpar$VV <- rep(MSCRAMBLE, numpredprey)
  
  #NOTE:  Original in C didn't set handleswitch for primary production groups.  Error?
  #probably not when group 0 biomass doesn't change from 1.
  simpar$HandleSwitch <- rep(PREYSWITCH, numpredprey)
  
  #scramble combined prey pools
  Btmp <- simpar$B_BaseRef
  py   <- simpar$PreyFrom + 1.0
  pd   <- simpar$PreyTo + 1.0
  VV   <- simpar$VV * simpar$QQ / Btmp[py]
  AA   <- (2.0 * simpar$QQ * VV) / (VV * Btmp[pd] * Btmp[py] - simpar$QQ * Btmp[pd])
  simpar$PredPredWeight <- AA * Btmp[pd] 
  simpar$PreyPreyWeight <- AA * Btmp[py] 
  
  simpar$PredTotWeight <- rep(0, length(simpar$B_BaseRef))
  simpar$PreyTotWeight <- rep(0, length(simpar$B_BaseRef))
  
  for(links in 1:numpredprey){
    simpar$PredTotWeight[py[links]] <- simpar$PredTotWeight[py[links]] + simpar$PredPredWeight[links]
    simpar$PreyTotWeight[pd[links]] <- simpar$PreyTotWeight[pd[links]] + simpar$PreyPreyWeight[links]    
  }  
  #simpar$PredTotWeight[]   <- as.numeric(tapply(simpar$PredPredWeight,py,sum))
  #simpar$PreyTotWeight[]   <- as.numeric(tapply(simpar$PreyPreyWeight,pd,sum))
  
  simpar$PredPredWeight <- simpar$PredPredWeight/simpar$PredTotWeight[py]
  simpar$PreyPreyWeight <- simpar$PreyPreyWeight/simpar$PreyTotWeight[pd]
  
  simpar$NumPredPreyLinks <- numpredprey
  simpar$PreyFrom       <- c(0, simpar$PreyFrom)
  simpar$PreyTo         <- c(0, simpar$PreyTo)
  simpar$QQ             <- c(0, simpar$QQ)
  simpar$DD             <- c(0, simpar$DD)
  simpar$VV             <- c(0, simpar$VV) 
  simpar$HandleSwitch   <- c(0, simpar$HandleSwitch) 
  simpar$PredPredWeight <- c(0, simpar$PredPredWeight)
  simpar$PreyPreyWeight <- c(0, simpar$PreyPreyWeight)
  
  #catchlinks
  fishfrom    <- row(as.matrix(Rpath$Catch))
  fishthrough <- col(as.matrix(Rpath$Catch)) + (Rpath$NUM_LIVING + Rpath$NUM_DEAD)
  fishcatch   <- Rpath$Catch
  fishto      <- fishfrom * 0
  
  if(sum(fishcatch) > 0){
    simpar$FishFrom    <- fishfrom   [fishcatch > 0]
    simpar$FishThrough <- fishthrough[fishcatch > 0]
    simpar$FishQ       <- fishcatch  [fishcatch > 0] / simpar$B_BaseRef[simpar$FishFrom + 1]  
    simpar$FishTo      <- fishto     [fishcatch > 0]
  }
  #discard links
  
  for(d in 1:Rpath$NUM_DEAD){
    detfate <- Rpath$DetFate[(Rpath$NUM_LIVING + Rpath$NUM_DEAD + 1):Rpath$NUM_GROUPS, d]
    detmat  <- t(matrix(detfate, Rpath$NUM_GEAR, Rpath$NUM_GROUPS))
    
    fishfrom    <-  row(as.matrix(Rpath$Discards))                      
    fishthrough <-  col(as.matrix(Rpath$Discards)) + (Rpath$NUM_LIVING + Rpath$NUM_DEAD)
    fishto      <-  t(matrix(Rpath$NUM_LIVING + d, Rpath$NUM_GEAR, Rpath$NUM_GROUPS))
    fishcatch   <-  Rpath$Discards * detmat
    if(sum(fishcatch) > 0){
      simpar$FishFrom    <- c(simpar$FishFrom,    fishfrom   [fishcatch > 0])
      simpar$FishThrough <- c(simpar$FishThrough, fishthrough[fishcatch > 0])
      ffrom <- fishfrom[fishcatch > 0]
      simpar$FishQ       <- c(simpar$FishQ,  fishcatch[fishcatch > 0] / simpar$B_BaseRef[ffrom + 1])  
      simpar$FishTo      <- c(simpar$FishTo, fishto   [fishcatch > 0])
    }
  } 
  
  simpar$NumFishingLinks <- length(simpar$FishFrom)  
  simpar$FishFrom        <- c(0, simpar$FishFrom)
  simpar$FishThrough     <- c(0, simpar$FishThrough)
  simpar$FishQ           <- c(0, simpar$FishQ)  
  simpar$FishTo          <- c(0, simpar$FishTo)   
  
# SET DETRITAL FLOW
  detfrac <- Rpath$DetFate[1:(Rpath$NUM_LIVING + Rpath$NUM_DEAD), ]
  detfrom <- row(as.matrix(detfrac))
  detto   <- col(as.matrix(detfrac)) + Rpath$NUM_LIVING
  
  detout <- 1 - rowSums(as.matrix(Rpath$DetFate[1:(Rpath$NUM_LIVING + Rpath$NUM_DEAD), ]))
  dofrom <- 1:length(detout)
  doto   <- rep(0, length(detout))
  
  simpar$DetFrac <- c(0, detfrac[detfrac > 0], detout[detout > 0])
  simpar$DetFrom <- c(0, detfrom[detfrac > 0], dofrom[detout > 0])
  simpar$DetTo   <- c(0, detto  [detfrac > 0], doto  [detout > 0])
  simpar$NumDetLinks <- length(simpar$DetFrac) - 1
  
# STATE VARIABLE DEFAULT 
  #simpar$state_BB    <- simpar$B_BaseRef
  #simpar$state_Ftime <- rep(1, length(Rpath$BB) + 1)
  simpar$BURN_YEARS <- -1
  simpar$COUPLED    <-  1
  simpar$CRASH_YEAR <- -1
  
  return(simpar)
}

